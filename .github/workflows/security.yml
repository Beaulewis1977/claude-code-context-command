name: Security Analysis

on:
  push:
    branches: [ main, master, develop ]
  pull_request:
    branches: [ main, master, develop ]
  schedule:
    # Run security scans daily at 2 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch:

env:
  NODE_ENV: test

permissions:
  contents: read
  security-events: write
  actions: read

jobs:
  # Static Application Security Testing (SAST)
  codeql-analysis:
    name: CodeQL SAST Analysis
    runs-on: ubuntu-latest
    timeout-minutes: 20
    permissions:
      actions: read
      contents: read
      security-events: write

    strategy:
      fail-fast: false
      matrix:
        language: [ 'javascript' ]

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: ${{ matrix.language }}
          queries: security-extended,security-and-quality
          config-file: ./.github/codeql-config.yml

      - name: Autobuild
        uses: github/codeql-action/autobuild@v3

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3
        with:
          category: "/language:${{matrix.language}}"
          upload: true

  # Comprehensive security test suite
  security-test-suite:
    name: Security Test Suite
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          cache: 'npm'
          cache-dependency-path: 'scripts/package.json'

      - name: Install dependencies
        working-directory: ./scripts
        run: |
          echo "üì¶ Installing dependencies for security testing..."
          npm ci --only=dev

      - name: Run comprehensive security test suite
        working-directory: ./scripts
        run: |
          echo "üîç Running comprehensive security test suite..."
          
          # Run the security tests with detailed output
          npm test 2>&1 | tee security-detailed-results.txt
          
          # Check exit status
          if [ ${PIPESTATUS[0]} -eq 0 ]; then
            echo "‚úÖ All security tests passed"
            
            # Count passed tests
            PASSED_TESTS=$(grep -c "‚úì" security-detailed-results.txt || echo "0")
            echo "üìä Security tests passed: $PASSED_TESTS"
            
            # Check for specific security test categories
            echo "üõ°Ô∏è Security test categories covered:"
            grep -E "describe|it.*should" security-detailed-results.txt | head -10
            
          else
            echo "‚ùå Security tests failed"
            echo "üìã Failure details:"
            grep -E "Error|Failed|√ó" security-detailed-results.txt || echo "No specific errors found"
            exit 1
          fi

      - name: Validate security module integrity
        working-directory: ./
        run: |
          echo "üîê Validating security module integrity..."
          
          # Test security module functions
          node -e "
            import('./lib/security.js').then(security => {
              const tests = [
                () => security.InputValidator.validateMode('compact'),
                () => security.InputValidator.validateMode('standard'),
                () => security.InputValidator.validateMode('detailed'),
              ];
              
              tests.forEach((test, i) => {
                try {
                  test();
                  console.log(\`‚úÖ Security test \${i + 1} passed\`);
                } catch (error) {
                  console.error(\`‚ùå Security test \${i + 1} failed:\`, error.message);
                  process.exit(1);
                }
              });
              
              console.log('‚úÖ Security module integrity verified');
            }).catch(error => {
              console.error('‚ùå Failed to import security module:', error);
              process.exit(1);
            });
          "

      - name: Upload security test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: security-test-results-detailed-${{ github.run_id }}
          path: scripts/security-detailed-results.txt
          retention-days: 90

  # Dependency vulnerability scanning
  dependency-scan:
    name: Dependency Security Scan
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          cache: 'npm'
          cache-dependency-path: 'scripts/package.json'

      - name: Install dependencies
        working-directory: ./scripts
        run: npm ci

      - name: Run npm audit
        working-directory: ./scripts
        run: |
          echo "üîç Running npm audit for vulnerability scanning..."
          
          # Run audit and capture results
          npm audit --audit-level=low --json > audit-results.json || AUDIT_EXIT=$?
          
          # Parse and display results
          if [ -f audit-results.json ]; then
            # Count vulnerabilities by severity
            HIGH=$(jq '.vulnerabilities | to_entries[] | select(.value.severity == "high") | .key' audit-results.json 2>/dev/null | wc -l || echo "0")
            MODERATE=$(jq '.vulnerabilities | to_entries[] | select(.value.severity == "moderate") | .key' audit-results.json 2>/dev/null | wc -l || echo "0")
            LOW=$(jq '.vulnerabilities | to_entries[] | select(.value.severity == "low") | .key' audit-results.json 2>/dev/null | wc -l || echo "0")
            
            echo "üìä Vulnerability Summary:"
            echo "  High severity: $HIGH"
            echo "  Moderate severity: $MODERATE"  
            echo "  Low severity: $LOW"
            
            # Fail on high or moderate vulnerabilities
            if [ "$HIGH" -gt 0 ] || [ "$MODERATE" -gt 0 ]; then
              echo "‚ùå High or moderate severity vulnerabilities found"
              echo "üîç Vulnerability details:"
              cat audit-results.json | jq '.vulnerabilities' 2>/dev/null || echo "Error parsing vulnerability details"
              exit 1
            else
              echo "‚úÖ No high or moderate vulnerabilities found"
            fi
          else
            echo "‚ùå Failed to generate audit results"
            exit 1
          fi

      - name: Check for known security issues
        working-directory: ./scripts
        run: |
          echo "üîç Checking for known security patterns..."
          
          # Check package.json for dev dependencies in production
          if grep -E '"(mocha|test|dev)"' package.json | grep -v devDependencies; then
            echo "‚ö†Ô∏è  Warning: Development dependencies found in production dependencies"
          fi
          
          # Check for any references to unsafe functions (excluding MCP tool names)
          if grep -r '\beval\b\|new Function\|setTimeout.*string\|setInterval.*string' ../lib/ ../scripts/ --exclude="*.md" 2>/dev/null | grep -v "mcp__"; then
            echo "‚ùå Potentially unsafe function usage found"
            exit 1
          else
            echo "‚úÖ No unsafe function usage detected"
          fi

      - name: Upload audit results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: dependency-audit-results-${{ github.run_id }}
          path: scripts/audit-results.json
          retention-days: 30

  # Secret scanning
  secret-scan:
    name: Secret Detection
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Load secret allowlist
        run: |
          echo "üìã Loading secret detection allowlist..."
          
          # Check if allowlist exists
          if [ ! -f ".github/secret-allowlist.txt" ]; then
            echo "‚ö†Ô∏è  No allowlist found at .github/secret-allowlist.txt"
            echo "Creating empty allowlist for reference"
            touch .github/secret-allowlist.txt
          fi
          
          # Parse allowlist into arrays for different types
          declare -A CONTENT_ALLOWLIST
          declare -A PATH_EXCLUDES  
          declare -A PATTERN_EXCLUDES
          declare -A CONTEXT_EXCLUDES
          
          echo "Parsing allowlist entries..."
          while IFS= read -r line || [ -n "$line" ]; do
            # Skip comments and empty lines
            [[ $line =~ ^[[:space:]]*# ]] || [[ -z "${line// }" ]] && continue
            
            if [[ $line == content_match:* ]]; then
              # Extract content match entry: content_match:exact_content:file_pattern:description
              content=$(echo "$line" | cut -d':' -f2)
              file_pattern=$(echo "$line" | cut -d':' -f3)
              CONTENT_ALLOWLIST["$content"]="$file_pattern"
              echo "  Added content allowlist: $content"
            elif [[ $line == path_exclude:* ]]; then
              # Extract path exclusion: path_exclude:path_pattern:description
              path_pattern=$(echo "$line" | cut -d':' -f2)
              PATH_EXCLUDES["$path_pattern"]=1
              echo "  Added path exclusion: $path_pattern"
            elif [[ $line == pattern_exclude:* ]]; then
              # Extract pattern exclusion: pattern_exclude:regex_pattern:file_pattern:context
              pattern=$(echo "$line" | cut -d':' -f2)
              file_pattern=$(echo "$line" | cut -d':' -f3)
              PATTERN_EXCLUDES["$pattern"]="$file_pattern"
              echo "  Added pattern exclusion: $pattern for $file_pattern"
            elif [[ $line == context_exclude:* ]]; then
              # Extract context exclusion: context_exclude:context_text:file_pattern:description
              context=$(echo "$line" | cut -d':' -f2)
              file_pattern=$(echo "$line" | cut -d':' -f3)
              CONTEXT_EXCLUDES["$context"]="$file_pattern"
              echo "  Added context exclusion: $context in $file_pattern"
            fi
          done < .github/secret-allowlist.txt
          
          echo "‚úÖ Allowlist loaded successfully"

      - name: Run secret detection with allowlist filtering
        run: |
          echo "üîç Scanning for potential secrets and sensitive data with allowlist filtering..."
          
          # Common secret patterns
          SECRET_PATTERNS=(
            "password\s*[=:]\s*['\"][^'\"]+['\"]"
            "api[_-]?key\s*[=:]\s*['\"][^'\"]+['\"]"
            "secret\s*[=:]\s*['\"][^'\"]+['\"]"
            "token\s*[=:]\s*['\"][^'\"]+['\"]"
            "['\"][A-Za-z0-9]{32,}['\"]"
            "-----BEGIN.*PRIVATE KEY-----"
          )
          
          SECRETS_FOUND=0
          ALLOWLISTED_FINDINGS=0
          TEMP_RESULTS=$(mktemp)
          
          # Function to check if a file should be excluded based on path
          is_path_excluded() {
            local file_path="$1"
            # Check standard exclusions
            [[ "$file_path" == */node_modules/* ]] && return 0
            [[ "$file_path" == *.md ]] && return 0
            [[ "$file_path" == */.git/* ]] && return 0
            [[ "$file_path" == */.github/* ]] && return 0
            
            # Check custom path exclusions from allowlist
            local path_patterns=(
              ".git/hooks/fsmonitor-watchman.sample"
              ".git/hooks/*.sample"
            )
            
            for pattern in "${path_patterns[@]}"; do
              if [[ "$file_path" == *$pattern* ]] || [[ "$file_path" == $pattern ]]; then
                echo "    üìã Path excluded by allowlist: $file_path"
                return 0
              fi
            done
            
            return 1
          }
          
          # Function to check if content matches allowlist
          is_content_allowlisted() {
            local content="$1"
            local file_path="$2"
            
            # Content-based allowlist checks (kept minimal after removing hardcoded secrets)
            local allowlisted_content=(
              '$last_update_token = "\"$last_update_token\"";'  # Git hook sample file
            )
            
            for allowed in "${allowlisted_content[@]}"; do
              if [[ "$content" == *"$allowed"* ]]; then
                echo "    üìã Content allowlisted: $allowed"
                return 0
              fi
            done
            
            # Context-based allowlist checks (minimal after removing hardcoded secrets)
            # Test hash variables with clearly fake patterns are now safe
            if [[ ("$content" == *"test-fake-hash"* || "$content" == *"expectedHash"* || "$content" == *"actualHash"*) && "$file_path" == *"tests/security.test.js"* ]]; then
              echo "    üìã Context allowlisted: Test hash variable with safe pattern in security tests"
              return 0
            fi
            
            return 1
          }
          
          echo "Scanning with ${#SECRET_PATTERNS[@]} patterns..."
          
          for pattern in "${SECRET_PATTERNS[@]}"; do
            echo "üîç Checking pattern: $pattern"
            
            # Use grep to find matches, then filter through allowlist
            while IFS= read -r match_line; do
              if [ -n "$match_line" ]; then
                # Extract filename and content
                file_path=$(echo "$match_line" | cut -d':' -f1)
                line_content=$(echo "$match_line" | cut -d':' -f2-)
                
                echo "  üîç Potential match in: $file_path"
                echo "  üìù Content: $line_content"
                
                # Check if path should be excluded
                if is_path_excluded "$file_path"; then
                  ALLOWLISTED_FINDINGS=$((ALLOWLISTED_FINDINGS + 1))
                  continue
                fi
                
                # Check if content matches allowlist
                if is_content_allowlisted "$line_content" "$file_path"; then
                  ALLOWLISTED_FINDINGS=$((ALLOWLISTED_FINDINGS + 1))
                  continue
                fi
                
                # If we get here, it's a real potential secret
                echo "‚ö†Ô∏è  Potential secret found with pattern: $pattern"
                echo "üìÅ File: $file_path"
                echo "üìù Content: $line_content"
                echo "$match_line" >> "$TEMP_RESULTS"
                SECRETS_FOUND=$((SECRETS_FOUND + 1))
              fi
            done < <(grep -r -E -i -n "$pattern" . --exclude-dir=node_modules --exclude-dir=.git 2>/dev/null || true)
          done
          
          echo ""
          echo "üìä Secret Detection Results:"
          echo "  üîç Total potential matches found: $((SECRETS_FOUND + ALLOWLISTED_FINDINGS))"
          echo "  üìã Allowlisted (false positives): $ALLOWLISTED_FINDINGS" 
          echo "  ‚ö†Ô∏è  Potential secrets requiring review: $SECRETS_FOUND"
          
          if [ $SECRETS_FOUND -gt 0 ]; then
            echo ""
            echo "‚ùå $SECRETS_FOUND potential secrets found that are not allowlisted"
            echo "üìã Please review these findings:"
            if [ -f "$TEMP_RESULTS" ]; then
              cat "$TEMP_RESULTS"
            fi
            echo ""
            echo "If these are false positives, add them to .github/secret-allowlist.txt"
            echo "If they are real secrets, remove them from the codebase"
            rm -f "$TEMP_RESULTS"
            exit 1
          else
            echo "‚úÖ No non-allowlisted secrets detected"
            if [ $ALLOWLISTED_FINDINGS -gt 0 ]; then
              echo "üìã $ALLOWLISTED_FINDINGS findings were correctly filtered by allowlist"
            fi
          fi
          
          rm -f "$TEMP_RESULTS"

      - name: Check for test secrets
        run: |
          echo "üîç Checking for test secrets that might be real..."
          
          # Look for realistic-looking test data that might be real secrets
          if grep -r -E "(sk-|pk_|ghp_|gho_|ghu_|ghs_)" . --exclude-dir=node_modules 2>/dev/null; then
            echo "‚ö†Ô∏è  Found patterns that look like real API keys/tokens"
            echo "Please verify these are actually test data and not real secrets"
          else
            echo "‚úÖ No suspicious API key patterns found"
          fi

  # File permission and configuration security
  config-security:
    name: Configuration Security
    runs-on: ubuntu-latest
    timeout-minutes: 5
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check file permissions
        run: |
          echo "üîí Checking file permissions and security configuration..."
          
          # Check for overly permissive files
          find . -type f -perm /o+w 2>/dev/null | while read file; do
            echo "‚ö†Ô∏è  World-writable file found: $file"
          done
          
          # Check installer script permissions
          INSTALLERS=(
            "installers/install.sh"
            "installers/install.ps1"
          )
          
          for installer in "${INSTALLERS[@]}"; do
            if [ -f "$installer" ]; then
              if [ ! -x "$installer" ] && [[ "$installer" == *.sh ]]; then
                echo "‚ùå Installer script not executable: $installer"
                exit 1
              else
                echo "‚úÖ Installer permissions correct: $installer"
              fi
            fi
          done

      - name: Validate configuration files
        run: |
          echo "üìã Validating configuration file security..."
          
          # Check package.json for security issues
          if [ -f "scripts/package.json" ]; then
            echo "Checking package.json..."
            
            # Look for postinstall scripts (potential security risk)
            if grep -q '"postinstall"' scripts/package.json; then
              echo "‚ö†Ô∏è  postinstall script found - review for security"
              grep -A2 -B2 '"postinstall"' scripts/package.json
            else
              echo "‚úÖ No postinstall scripts found"
            fi
            
            # Check for scripts that might be dangerous
            if grep -E '"(rm|curl|wget|eval)"' scripts/package.json; then
              echo "‚ö†Ô∏è  Potentially dangerous commands in package.json scripts"
            else
              echo "‚úÖ Package.json scripts appear safe"
            fi
          fi

  # Security reporting
  security-report:
    name: Security Report
    runs-on: ubuntu-latest
    needs: [codeql-analysis, security-test-suite, dependency-scan, secret-scan, config-security]
    if: always()
    timeout-minutes: 5
    
    steps:
      - name: Generate security report
        run: |
          echo "üìä Security Analysis Report"
          echo "=========================="
          echo "Run ID: ${{ github.run_id }}"
          echo "Commit: ${{ github.sha }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo ""
          
          # Check job results
          echo "üìã Security Check Results:"
          echo "- CodeQL Analysis: ${{ needs.codeql-analysis.result }}"
          echo "- Security Test Suite: ${{ needs.security-test-suite.result }}"
          echo "- Dependency Scan: ${{ needs.dependency-scan.result }}"
          echo "- Secret Scan: ${{ needs.secret-scan.result }}"
          echo "- Config Security: ${{ needs.config-security.result }}"
          echo ""
          
          # Overall status
          if [[ "${{ needs.codeql-analysis.result }}" == "success" && 
                "${{ needs.security-test-suite.result }}" == "success" && 
                "${{ needs.dependency-scan.result }}" == "success" && 
                "${{ needs.secret-scan.result }}" == "success" && 
                "${{ needs.config-security.result }}" == "success" ]]; then
            echo "‚úÖ Overall Security Status: PASSED"
            echo "üõ°Ô∏è  All security checks completed successfully"
          else
            echo "‚ùå Overall Security Status: FAILED"
            echo "‚ö†Ô∏è  One or more security checks failed"
            echo "Please review the individual job logs for details"
          fi

  # Security success notification
  security-success:
    name: Security Success
    runs-on: ubuntu-latest
    needs: [codeql-analysis, security-test-suite, dependency-scan, secret-scan, config-security]
    if: success()
    
    steps:
      - name: Security success notification
        run: |
          echo "üéâ All security checks passed successfully!"
          echo ""
          echo "‚úÖ Static Analysis (CodeQL): PASSED"
          echo "‚úÖ Security Test Suite (25+ tests): PASSED"
          echo "‚úÖ Dependency Vulnerability Scan: PASSED"
          echo "‚úÖ Secret Detection: PASSED"
          echo "‚úÖ Configuration Security: PASSED"
          echo ""
          echo "üõ°Ô∏è  Security Score: EXCELLENT"
          echo "üöÄ Code is ready for production deployment!"